//
//  SearchRecordController.m
//  DigitalNewzealandRR
//
//  This file was automatically generated by APIMATIC BETA v2.0 on 06/29/2016
//
#import "SearchRecordController.h"

@implementation SearchRecordController

/**
* The Search Records API call returns a result set in response to a search query. The v3 Search Records API request parameters and response format differs significantly from the deprecated v1 & v2 Search Records API call.
* @param  SearchRecordInput     Object with all parameters
* @return	Returns the CollectionSearchRecords* response from the API call */
- (void) searchRecordAsyncWithSearchRecordInput:(SearchRecordInput*) input
                completionBlock:(CompletedGetSearchRecord) onCompleted
{
    //the base uri for api requests
    NSString* baseUri = [NSString stringWithString: (NSString*) [Configuration BaseUri]];

    //prepare query string for API call
    NSMutableString* queryBuilder = [NSMutableString stringWithString: baseUri]; 
    [queryBuilder appendString: @"/v3/records.json"];

    //process optional query parameters
    [APIHelper appendUrl: queryBuilder withQueryParameters: @{
                    @"facet_per_page": [NSNumber numberWithInteger:input.facetPerPage],
                    @"facets_page": [NSNumber numberWithInteger:input.facetsPage],
                    @"page": [NSNumber numberWithInteger:input.page],
                    @"per_page": [NSNumber numberWithInteger:input.perPage],
                    @"text": input.text,
                    @"and": (nil != input.and) ? input.and : [NSNull null],
                    @"direction": (nil != input.direction) ? input.direction : [NSNull null],
                    @"facets": (nil != input.facets) ? input.facets : [NSNull null],
                    @"geo_bbox": (nil != input.geoBbox) ? input.geoBbox : [NSNull null],
                    @"or": (nil != input.or) ? input.or : [NSNull null],
                    @"sort": (nil != input.sort) ? input.sort : [NSNull null],
                    @"without": (nil != input.without) ? input.without : [NSNull null],
                    @"api_key": [Configuration ApiKey]
                }];

    //validate and preprocess url
    NSString* queryUrl = [APIHelper cleanUrl: queryBuilder];

    //preparing request headers
    NSMutableDictionary* headers = [[NSMutableDictionary alloc] initWithDictionary: @{
        @"user-agent": @"APIMATIC 2.0",
        @"accept": @"application/json"
    }];

    //Remove null values from header collection in order to omit from request
    [APIHelper removeNullValues: headers];


    //prepare the request and fetch response  
    HttpRequest* request = [[self clientInstance] get: ^(HttpRequest* request) 
    { 
        [request setQueryUrl: queryUrl]; //set request url        
        [request setHeaders: headers]; //set request headers

    }];

    //use the instance of the http client to make the actual call
    [[self clientInstance]
     executeAsString: request
     success: ^(id context, HttpResponse *response) {
         //Error handling using HTTP status codes
         NSError* statusError = nil;

         //Error handling using HTTP status codes 
         if((response.statusCode < 200) || (response.statusCode > 206)) //[200,206] = HTTP OK
             statusError = [[APIError alloc] initWithReason: @"HTTP Response Not OK"
                                                    andCode: response.statusCode
                                                    andData: response.rawBody];

         if(statusError != nil)
         {
             //announce completion with failure due to HTTP status code checking
             onCompleted(NO, context, nil, statusError);
         }
         else
         {
             //return response to API caller
             NSString* strResult = [(HttpStringResponse*)response body];
             CollectionSearchRecords* result = (CollectionSearchRecords*) [APIHelper jsonDeserialize: strResult
                toClass: CollectionSearchRecords.class];

 
             //announce completion with success
             onCompleted(YES, context, result, nil);
         }
     } failure:^(id context, NSError *error) {
 
         //announce completion with failure
         onCompleted(NO, context, nil, error);
     }];
}


@end